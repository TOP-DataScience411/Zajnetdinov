ПРОДВИНУТАЯ РАБОТА С ФУНКЦИЯМИ

  ==========  1  ==========  

Написать генераторную функцию с именем deck, которая создаёт упорядоченную колоду карт.

Функция не принимает аргументы.

Функция возвращает объект генератор.
    
    На каждой итерации или при явном вызове встроенного метода __next__() генератор должен возвращать кортеж из двух элементов:
        - целое число, обозначающее номинал карты: 2, 3 ... 10, 11 — валет, 12 — дама, 13 — король, 14 — туз
        - строка, обозначающая масть карты: 'черви', 'бубны', 'пики', 'трефы'

Колода упорядочивается следующим образом: сначала все номиналы червей, затем все номиналы бубен, затем все номиналы пик и в конце все номиналы треф.

Написанную функцию необходимо протестировать вручную.
Пример ручного теста:
    >>> list(deck())[::13]
    [(2, 'черви'), (2, 'бубны'), (2, 'пики'), (2, 'трефы')]



  ==========  2  ==========  

Написать рекурсивную функцию с именем product, которая возвращает произведение чисел.

Функция принимает обязательным позиционно-ключевым аргументом итерируемый объект с числами в качестве элементов.

Функция возвращает объект float.

Подумайте об оптимизации работы функции в рамках указанных требований.

Работу написанной функции необходимо проверить.

Пример проверки:
    >>> product(range(10, 60, 10))
    12000000.0
    >>> 
    >>> product((0.12, 0.05, -0.09, 0.0, 0.21))
    0.0



  ==========  3  ==========  

Написать рекурсивную функцию с именем tree_leaves, которая считает количество листьев на дереве.

Функция принимает обязательным позиционно-ключевым аргументом список веток дерева.
    
    Роль листа будет играть строка 'leaf'.
    Каждая ветка дерева может содержать вложенные ветки и листья. То есть элементами исходного списка могут быть строки (листья) и списки (ветки), которые в свою очередь могут содержать как листья, так и строки (см. пример проверки).
    
    Поскольку речь идёт о произвольной структуре данных, то в аннотации параметра функции тип элементов не указывается.

Функция возвращает объект int.

Работу написанной функции необходимо проверить.

Пример проверки:
    >>> tree = [[[['leaf', 'leaf', 'leaf', 'leaf'], 'leaf', 'leaf', 'leaf'], [['leaf', 'leaf'], 'leaf', 'leaf'], ['leaf', 'leaf', 'leaf']], [['leaf', 'leaf'], ['leaf', 'leaf', 'leaf', 'leaf', 'leaf', 'leaf'], 'leaf', 'leaf', 'leaf'], [['leaf'], ['leaf', 'leaf', ['leaf', 'leaf', 'leaf']], 'leaf', 'leaf'], ['leaf', 'leaf', ['leaf', 'leaf'], 'leaf']]
    >>> 
    >>> tree_leaves(tree)
    38



  ==========  4  ==========  дополнительно

Написать рекурсивную функцию с именем tree_generator, которая генерирует дерево с произвольным количеством веток и листьев.

Вложенность веток также должна быть произвольной.

Функция не принимает аргументы.
    
    Роль листа должна играть строка 'leaf'.

Функция возвращает объект list.
    
    Добейтесь такого поведения, чтобы возвращаемый список не мог быть пустым, но вложенные списки (ветки) могли.

Подсказка: используйте функцию randrange() из модуля random стандартной библиотеки.

Работу написанной функции необходимо проверить.

Пример проверки:
    >>> tree_generator()
    [[], ['leaf', 'leaf'], [['leaf'], [[['leaf']], [['leaf', 'leaf']], ['leaf', 'leaf'], ['leaf', 'leaf'], []], ['leaf', 'leaf', 'leaf'], [[], ['leaf', 'leaf', 'leaf'], [['leaf', 'leaf']], [['leaf', 'leaf'], [[['leaf']]], ['leaf'], [[['leaf'], [['leaf', 'leaf'], ['leaf'], [], [[[]]], ['leaf', 'leaf']]], [], [[], ['leaf']], [['leaf', 'leaf'], [['leaf'], []], ['leaf', 'leaf'], []], ['leaf']], ['leaf', 'leaf']]], ['leaf', 'leaf']], ['leaf', 'leaf', 'leaf'], ['leaf']]
    >>>
    >>> tree_generator()
    [['leaf', 'leaf'], ['leaf', 'leaf']]


  =========================  

Каждая функция должна быть документирована, её параметры и возвращаемое значение должны быть аннотированы.

Работа функций проверяется в режиме инспекции файла с кодом.
Ввод и вывод в стандартные потоки результатов проверки копируются.
Копия в виде комментария помещается в конец файла с кодом задачи.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.