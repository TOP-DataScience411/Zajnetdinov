РАБОТА С ПУТЯМИ, ФАЙЛОВЫЙ ВВОД/ВЫВОД

  ==========  1  ==========  

Написать функцию с именем list_files, которая возвращает кортеж с именами файлов в каталоге по переданному пути.

Файлы во вложенных каталогах функция искать не должна — то есть осуществляется нерекурсивный поиск.

Для проверки можно использовать каталог data в каталоге задания. Или любой другой каталог с файлами и вложенными каталогами.

Функция принимает обязательным позиционно-ключевым аргументом абсолютный путь к каталогу в виде объекта str.
    
    Необходимо помнить об экранировании обратных слэшей в windows-путях. 
    Или использовать r-строки, но даже в r-строке обратный слэш не должен быть последним символом.

Функция возвращает кортеж с именами файлов или None.
    
    В случае, если по переданному пути отсутствует каталог, функция возвращает None.

В данной задаче необходимо использовать объекты Path из модуля pathlib стандартной библиотеки.

Написанную функцию необходимо протестировать вручную.
Пример ручного теста (cmd):
    D:\student\2023.05.28 > tree /f
    
    2023.05.28
    │   7MD9i.chm
    │   conf.py
    │   E3ln1.txt
    │   F1jws.jpg
    │   le1UO.txt
    │   q40Kv.docx
    │   r62Bf.txt
    │   xcD1a.zip
    │
    ├───c14KE
    │       5vsIh.dat
    │       P2a91.dat
    │
    └───mXbd9
            RoBjg.pt
            z03EN.pt    
    
    D:\student\2023.05.28 > python -i 1.py
    >>> list_files(r'd:\student\2023.05.28\data')
    ('7MD9i.chm', 'conf.py', 'E3ln1.txt', 'F1jws.jpg', 'le1UO.txt', 'q40Kv.docx', 'r62Bf.txt', 'xcD1a.zip')



  ==========  2  ==========  

Написать функцию с именем load_data, которая читает из файлов данные и упорядочивает их.
Написать функцию с именем generate_person, которая генерирует анкету человека со случайными данными.

Имена, отчества и фамилии записаны в трёх текстовых файлах в каталоге data/names.
С помощью функции load_data() необходимо записать все эти данные в один словарь names в глобальном пространстве имён. 
Структуру словаря names продумайте самостоятельно — выберите самый, как вам кажется, удобный вариант для дальнейшей работы функции generate_person()

Функция load_data() не принимает аргументы.

Функция load_data() возвращает None.

Функция generate_person() не принимает аргументы.

Функция generate_person() возвращает словарь с анкетными данными.
    
    Ключи словаря:
        'имя': str
        'отчество': str
        'фамилия': str
        'пол': typing.Literal['мужской', 'женский']
        'дата рождения': datetime.date
        'мобильный': str
        
        С помощью специального дженерика Literal из модуля typing стандартной библиотеки можно перечислить конкретные значения, ожидаемые для аннотируемого идентификатора.

Условия генерации случайных данных:
    
    Имя, отчество и фамилия должны быть согласованы по полу человека.
    
    При генерации случайной даты рождения необходимо учитывать количество дней в каждом месяце с учётом високосного года.
    
    Для генерации года рождения используйте в качестве диапазона одно столетие.
    
    Формат мобильного номера +79xxxxxxxxx

Вы можете дополнительно реализовать любое количество вспомогательных функций с произвольными сигнатурами и любое количество вспомогательных структур данных.

Написанные функции необходимо протестировать.

Примеры тестов:
    >>> from pprint import pprint
    >>> 
    >>> load_data()
    >>> 
    >>> pprint(generate_person(), sort_dicts=False)
    {'имя': 'Аделаида',
     'отчество': 'Алексеевна',
     'фамилия': 'Эдемская',
     'пол': 'женский',
     'дата рождения': datetime.date(1947, 11, 5),
     'мобильный': '+79357908261'}
    >>> 
    >>> pprint(generate_person(), sort_dicts=False)
    {'имя': 'Марлен',
     'отчество': 'Харлампович',
     'фамилия': 'Садовский',
     'пол': 'мужской',
     'дата рождения': datetime.date(1973, 8, 16),
     'мобильный': '+79981756023'}
    >>> 



  ==========  3  ==========  

Написать функцию с именем ask_for_file, которая запрашивает у пользователя путь к потерянному файлу и копирует этот файл с помощью функции load_file.

Иногда приложение не может обнаружить необходимые файлы в каталогах по умолчанию. В таких случаях приложение запрашивает у пользователя путь, по которому можно найти потерянный файл. Далее файл может использоваться приложением там, где он находится. А может быть скопирован в каталоги приложения. Чтобы научиться плотнее взаимодействовать с файловой системой вам необходимо реализовать именно второй вариант.

Роль "потерянного" файла будет играть файл data/conf.py

Объявление функции ask_for_file помещается в файл 3.py
Объявление функции load_file помещается в файл utils.py в том же каталоге (каталог задания).

Функция ask_for_file не принимает аргументы.

    Во время выполнения функции ask_for_file необходимо получить из терминала путь к файлу. Если путь не корректный (не существует файл по указанному пути), то в терминал выводится сообщение об ошибке и путь запрашивается повторно. Повторять, пока не будет получен корректный путь.
    
    Далее из функции ask_for_file вызывается функция load_file. 
    
    После успешного копирования файла, из функции ask_for_file импортируется 
        
        Данная задача работает с конкретным "потерянным" файлом, его имя известно, следовательно можно выполнить импорт с помощью инструкции import
        
        Однако, если вы хотите написать более универсальные функции для поиска, копирования и подключения произвольного файла, то используйте функции spec_from_file_location() и module_from_spec() из модуля importlib.util стандартной библиотеки.

Функция ask_for_file возвращает объект модуля, созданного при импортировании файла.
    
    Обратите внимание, что в данной задаче вам заранее изветно имя "потерянного" файла.

Функция load_file принимает обязательным аргументом путь к файлу.
    
    Путь к файлу должен быть позиционно-ключевым аргументом, передаётся в виде объекта str или Path.
        Аннотация объектов осуществляется по имени класса:
        >>> from pathlib import Path
        >>> 
        >>> def testing_function(file_path: Path):
        ...     pass
        ... 
        >>> 
    
    Функция load_file осуществляет копирование файла по переданному пути в основной каталог (каталог задания).
        Для копирования файла используйте функцию copy2() из модуля shutil стандартной библиотеки:
            https://docs.python.org/3/library/shutil.html#shutil.copy2

Функция load_file возвращает путь к созданной в нужном каталоге копии файла.

Написанную функцию необходимо протестировать вручную.
Пример ручного теста:
    >>> config_module = ask_for_file()
    путь: d:\student\2023.05.28\conf.py
    ! по указанному пути отсутствует необходимый файл !
    путь: d:\student\2023.05.28\data\conf.py
    >>> 
    >>> config_module.defaults
    {'parameter1': 'value1', 'parameter2': 'value2', 'parameter3': 'value3', 'parameter4': 'value4'}



  ==========  4  ==========  дополнительно

Написать функцию с именем search_context, которая осуществляет поиск в текстовых файлах строчек, содержащих ключевые слова.

В этой задаче под текстовыми будут подразумеваться только файлы с расширением .txt
Текстовые файлы расположены в каталоге data среди прочих файлов. Программа не должна пытаться осуществлять поиск в других файлах, даже если технически они также являются текстовыми (например, conf.py).

Строчками в текстовом файле считается часть текста от символа конца строки (или от начала файла) до символа конца строки (или до конца файла).

Допустить совпадения вне зависимости от регистра: например "Время" считается совпадением для ключевого слова "время".

Допустить совпадения расширяющих, но не изменяющих словоформ: например, "встретился" считается совпадением для ключевого слова "встретил", но "новейший" не считается совпадением для "новый".

Реализовать возможность сохранить контекст: n строчек перед и n строчек после строчки, содержащей ключевое слово.

Функция принимает обязательным аргументом ключевое слово, далее произвольное количество ключевых слов и необязательным аргументом количество строк контекста.
    
    Ключевое слово должно быть позиционно-ключевым аргументом, передаётся в виде объекта str.
    
    Дальнейшие ключевые слова передаются с помощью произвольного кортежа позиционных аргументов, каждый из которых также должен являться объектом str.
    
    Количество строчек контекста n должно быть строго ключевым аргументом со значением по умолчанию 0, передаётся в виде объекта int.

Функция возвращает список словарей.
    
    Для каждого совпадения формируется словарь.
    
    Ключи и типы значений словаря:
        - 'keyword': str  — ключевое слово
        - 'filename': str — имя файла
        - 'line': int     — номер строчки с ключевым словом
        - 'context': int  — количество строчек до/после ключевой
        - 'text': str     — найденная(-ые) строчка(-и)
    
    Нумерацию строчек в файле начинать с единицы.
    
    Состав словаря аннотировать не нужно.

Возможно создание вспомогательных функций с произвольными сигнатурами. Все вспомогательные функции должны быть объявлены в файле utils.py

Написанную функцию необходимо протестировать вручную.
Пример ручного теста:
    >>> from pprint import pprint
    >>> 
    >>> pprint(search_context('мысль', 'мысли'))
    [{'context': 0,
      'filename': 'E3ln1.txt',
      'keyword': 'мысль',
      'line': 147,
      'text': ' - А знаете, Павел Иванович, - сказал Манилов, которому очень '
              'понравилась такая мысль, - как было бы в самом деле хорошо, если бы '
              'жить этак вместе, под одною кровлею, или под тенью какого-нибудь '
              'вяза пофилософствовать о чем-нибудь, углубиться!..'},
     {'context': 0,
      'filename': 'E3ln1.txt',
      'keyword': 'мысль',
      'line': 163,
      'text': 'Манилов долго стоял на крыльце, провожая глазами удалявшуюся '
              'бричку, и когда она уже совершенно стала не видна, он все еще '
              'стоял, куря трубку. Наконец вошел он в комнату, сел на стуле и '
              'предался размышлению, душевно радуясь, что доставил гостю своему '
              'небольшое удовольствие. Потом мысли его перенеслись незаметно к '
              'другим предметам и наконец занеслись бог знает куда. Он думал о '
              'благополучии дружеской жизни, о том, как бы хорошо было жить с '
              'другом на берегу какой-нибудь реки, потом чрез эту реку начал '
              'строиться у него мост, потом огромнейший дом с таким высоким '
              'бельведером, что можно оттуда видеть даже Москву, и там пить '
              'вечером чай на открытом воздухе и рассуждать о каких-нибудь '
              'приятных предметах. Потом, что они вместе с Чичиковым приехали в '
              'какое-то общество в хороших каретах, где обворожают всех '
              'приятностию обращения, и что будто бы государь, узнавши о такой их '
              'дружбе, пожаловал их генералами, и далее, наконец, бог знает что '
              'такое, чего уже он и сам никак не мог разобрать. Странная просьба '
              'Чичикова прервала вдруг все его мечтания. Мысль о ней как-то '
              'особенно не варилась в его голове: как ни переворачивал он ее, но '
              'никак не мог изъяснить себе, и все время сидел он и курил трубку, '
              'что тянулось до самого ужина.'},
     {'context': 0,
      'filename': 'E3ln1.txt',
      'keyword': 'мысли',
      'line': 163,
      'text': 'Манилов долго стоял на крыльце, провожая глазами удалявшуюся '
              'бричку, и когда она уже совершенно стала не видна, он все еще '
              'стоял, куря трубку. Наконец вошел он в комнату, сел на стуле и '
              'предался размышлению, душевно радуясь, что доставил гостю своему '
              'небольшое удовольствие. Потом мысли его перенеслись незаметно к '
              'другим предметам и наконец занеслись бог знает куда. Он думал о '
              'благополучии дружеской жизни, о том, как бы хорошо было жить с '
              'другом на берегу какой-нибудь реки, потом чрез эту реку начал '
              'строиться у него мост, потом огромнейший дом с таким высоким '
              'бельведером, что можно оттуда видеть даже Москву, и там пить '
              'вечером чай на открытом воздухе и рассуждать о каких-нибудь '
              'приятных предметах. Потом, что они вместе с Чичиковым приехали в '
              'какое-то общество в хороших каретах, где обворожают всех '
              'приятностию обращения, и что будто бы государь, узнавши о такой их '
              'дружбе, пожаловал их генералами, и далее, наконец, бог знает что '
              'такое, чего уже он и сам никак не мог разобрать. Странная просьба '
              'Чичикова прервала вдруг все его мечтания. Мысль о ней как-то '
              'особенно не варилась в его голове: как ни переворачивал он ее, но '
              'никак не мог изъяснить себе, и все время сидел он и курил трубку, '
              'что тянулось до самого ужина.'},
     {'context': 0,
      'filename': 'le1UO.txt',
      'keyword': 'мысли',
      'line': 13,
      'text': 'Как и все старые люди вообще, графиня страдала бессонницею. '
              'Раздевшись, она села у окна в вольтеровы кресла и отослала '
              'горничных. Свечи вынесли, комната опять осветилась одною лампадою. '
              'Графиня сидела вся желтая, шевеля отвислыми губами, качаясь направо '
              'и налево. В мутных глазах ее изображалось совершенное отсутствие '
              'мысли; смотря на нее, можно было бы подумать, что качание страшной '
              'старухи происходило не от ее воли, но по действию скрытого '
              'гальванизма.'},
     {'context': 0,
      'filename': 'r62Bf.txt',
      'keyword': 'мысль',
      'line': 19,
      'text': 'Вдруг он вздрогнул: одна, тоже вчерашняя, мысль опять пронеслась в '
              'его голове. Но вздрогнул он не оттого, что пронеслась эта мысль. Он '
              'ведь знал, он предчувствовал, что она непременно «пронесется», и '
              'уже ждал ее; да и мысль эта была совсем не вчерашняя. Но разница '
              'была в том, что месяц назад, и даже вчера еще, она была только '
              'мечтой, а теперь… теперь явилась вдруг не мечтой, а в каком-то '
              'новом, грозном и совсем незнакомом ему виде, и он вдруг сам сознал '
              'это… Ему стукнуло в голову, и потемнело в глазах.'},
     {'context': 0,
      'filename': 'r62Bf.txt',
      'keyword': 'мысли',
      'line': 61,
      'text': 'Несмотря на эти странные слова, ему стало очень тяжело. Он присел '
              'на оставленную скамью. Мысли его были рассеянны… Да и вообще тяжело '
              'ему было думать в эту минуту о чем бы то ни было. Он бы хотел '
              'совсем забыться, все забыть, потом проснуться и начать совсем '
              'сызнова…'},
     {'context': 0,
      'filename': 'r62Bf.txt',
      'keyword': 'мысль',
      'line': 63,
      'text': '«А куда ж я иду? - подумал он вдруг. - Странно. Ведь я зачем-то '
              'пошел. Как письмо прочел, так и пошел… На Васильевский остров, к '
              'Разумихину я пошел, вот куда, теперь… помню. Да зачем, однако же? И '
              'каким образом мысль идти к Разумихину залетела мне именно теперь в '
              'голову? Это замечательно».'}]



  ==========  5  ==========  дополнительно

Написать игру викторина.

Игра будет проходить в режиме сессии: один запуск приложения — одна сессия.
На каждой игровой сессии в терминал должны быть по очереди выведены вопросы с вариантами ответа, из которых необходимо выбрать правильный. Номер правильного ответа игрок вводит в терминале. При этом игрок должен уложиться в заданное время.
Для каждой игровой сессии ведётся счёт. За правильный ответ в отведённое время начисляется максимум баллов. За правильный, но просроченный ответ начисляется меньшее количество баллов. За неправильный ответ начисляется ноль баллов.

Есть база вопросов — в данном случае её роль будет играть текстовый файл data/questions.quiz
    Символ '+' в конце строки с ответом означает, что этот ответ является верным.

    Содержимое файла необходимо поместить в структуру данных, с которой в дальнейшем будет удобно работать. 
        
        Предлагается следующая структура:
        data = {
            'текст вопроса 1': {
                'ответ1': False,  # неверный
                'ответ2': True,   # верный
                'ответ3': False,  # неверный
                'ответ4': False,  # неверный
            }, 
            'текст вопроса 2': {
                'ответ1': False,  # неверный
                'ответ2': False,  # неверный
                'ответ3': False,  # неверный
                'ответ4': True,   # верный
            }, 
            ...
        }
        Возможны и другие варианты. 
            Если будете пробовать другой вариант, то обязательно аргументируйте свой выбор в комментариях к коду.

Вопросы для одной сессии выбираются случайным образом. Для реализации такого поведения можно воспользоваться функцией sample из модуля random стандартной библиотеки:
    https://docs.python.org/3/library/random.html#random.sample
    
    >>> sample(range(10, 100), 5)
    [17, 22, 59, 66, 12]
    >>> sample(range(10, 100), 5)
    [96, 33, 65, 25, 98]
    >>> sample(range(10, 100), 3)
    [34, 70, 10]
    >>> sample(range(10, 100), 3)
    [33, 69, 94]
    
    Ответы к каждому вопросу также должны выводиться в случайном порядке.

Для того чтобы засечь время можно воспользоваться функцией perf_counter из модуля time стандартной библиотеки:
    https://docs.python.org/3/library/time.html#time.perf_counter
    
    Функция работает с помощью счётчиков ОС, поэтому засекается реальное время, в том числе и время ожидания ввода пользователя:
    >>> start = perf_counter()
    >>> end = perf_counter()
    >>> end - start
    1.7119246000074781
    
    Внимание: не ставится задача прервать пользовательский ввод по истечении времени. Приложение только засекает, сколько игрок тратит времени на ответ на вопрос. И затем сравнивает полученное значение с установленным.

Файл 5.py должен являться точкой входа и содержать управляющую работой приложения функцию с именем main.
    
    Дополнительные функции могут использоваться в любом количестве и с любыми сигнатурами. Их объявления должны быть помещены в файл utils.py
        Например, для вывода заголовка приложения стоит воспользоваться ранее написанной функцией important_message.
    
    Воспользуйтесь также файлом data/vars.py, в котором уже объявлен ряд необходимых в работе переменных. Импорт файла, находящегося в подкаталоге относительно текущего скрипта, может осуществляться с использованием пакетной нотации:
    >>> import data.vars
    >>> data.vars.N
    5

Написанную программу необходимо протестировать вручную.
Пример ручного теста:
    >>> main()
    #=============================================================================#
    #                                                                             #
    #                         ИСТОРИЧЕСКАЯ БЛИЦ-ВИКТОРИНА                         #
    #                                                                             #
    #=============================================================================#
    
    Приветствуем в викторине по истории!
    Проверьте своё знание истории России с помощью интересных вопросов.
    
    Все вопросы имеют варианты ответов, среди них только один верный. За отведённое время (20 с) вам необходимо ввести номер варианта после приглашения для ввода и нажать клавишу Enter.
    
    
    Изображение какого евангелиста украшало первую печатную русскую книгу?
      1. Матфей
      2. Лука
      3. Марк
      4. Иоанн
     > 2
    Верно, но недостаточно быстро. (28 с)
    
    Кто построил первый в России паровоз?
      1. Ползунов
      2. Братья Черепановы
      3. Кулибин
      4. Клейнмихель
     > 2
    Верно! (4 с)
    
    Какой из этих пассажирских самолётов был первым в СССР реактивным авиалайнером?
      1. Ан-24
      2. Як-40
      3. Ту-104
      4. Ил-62
     > в
    ! введите цифру номера ответа !
     > 3
    Верно! (2 с)
    
    В каком городе в XI веке впервые на Руси появились колокола?
      1. В Москве
      2. В Новгороде
      3. В Рязани
      4. В Астрахани
     > 2
    Верно, но недостаточно быстро. (27 с)
    
    Кто был первой женщиной-правительницей на Руси?
      1. Елизавета
      2. Ольга
      3. Екатерина
      4. Мария
     > 1
    Неверно...
    
    Ваш счёт: 60
    >>>



  =========================

Каждая функция должна быть документирована, её параметры и возвращаемое значение должны быть аннотированы.

Функции тестируются в режиме инспекции файла с кодом.
Ввод и вывод в стандартные потоки тестов и их результатов копируются.
Копия в виде комментария помещается в конец файла с кодом задачи.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении всех частей задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.