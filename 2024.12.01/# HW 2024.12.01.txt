СТАНДАРТНАЯ БИБЛИОТЕКА

  ==========  1  ==========  

Написать функцию с именем schedule, которая генерирует график проведения мероприятий по заданным условиям.

Данная функция предназначена для расчёта дат еженедельно повторяющихся событий.
Мы будем использовать данную функцию для генерации графиков занятий.

Функция принимает обязательным аргументом дату первого мероприятия в графике, обязательным аргументом один и более номеров дней недели, далее обязательным аргументом общее количество занятий, и необязательным аргументом формат строкового представления генерируемых дат.
    
    Дата первого мероприятия должна быть строго позиционным аргументом, передаётся в виде объекта datetime.date
    
    Первый номер дня недели должен быть строго позиционным аргументом. Последующие номера дней недели должны быть произвольным кортежем позиционных аргументов. Передаются в виде объектов int.
        
        Номера дней недели обозначают, какие дни каждой недели должны войти в график. 
        Используется система нумерации ISO: 1 — понедельник, 2 — вторник, ...
    
    Общее количество занятий должно быть строго ключевым аргументов, передаётся в виде объекта int
    
    Формат строкового представления дат должен быть строго ключевым аргументом, передаётся в виде объекта str, значение по умолчанию '%d/%m/%Y'

Помимо передаваемых аргументов, функция может использовать список vacations из глобального пространства имён, если такое имя существует в глобальном пространстве имён.
    
    В данном списке указываются периоды, которые должны быть исключены из графика.
    
    Элементами списка являются кортежи из двух элементов:
        vacations: list[tuple[datetime.date, datetime.timedelta]]
    
    Первый элемент — дата начала исключаемого периода. Второй элемент — длительность исключаемого периода. (см. пример теста)

Функция возвращает список строковых представлений дат в заданном формате.

Вы можете дополнительно реализовать любое количество вспомогательных функций с произвольными сигнатурами.

Примечание: не забывайте про встроенные функции globals(), any() и map(), а также про функции модуля itertools

Написанную функцию необходимо протестировать.

Пример теста:
    >>> vacations = [
    ...     (date(2023, 5, 1), timedelta(weeks=1)),
    ...     (date(2023, 7, 17), timedelta(weeks=1)),
    ... ]
    >>>
    >>> py321 = schedule(date(2023, 4, 1), 6, 7, total_days=70)
    >>>
    >>> len(py321)
    70
    >>> py321[28:32]
    ['15/07/2023', '16/07/2023', '29/07/2023', '30/07/2023']



  ==========  2  ==========  дополнительно

Написать функцию с именем json_from_html, которая по заданному шаблону извлекает из HTML документа структурируемые данные и помещает их в JSON файл.

Получить HTTP ответ от удалённого сервера можно с помощью функции urlopen() из модуля urllib.request стандартной библиотеки
    https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen
    
    Функция urlopen() возвращает объект http.client.HTTPResponse — метод read() данного объекта возвращает тело ответа, являющееся в большинстве случаев HTML документом:
        https://docs.python.org/3/library/http.client.html#httpresponse-objects
    
    >>> from urllib.request import urlopen
    >>> 
    >>> with urlopen('https://www.python.org') as response:
    ...     html = response.read()
    ...
    >>> html[:55]
    b'<!doctype html>\n<!--[if lt IE 7]>   <html class="no-js '
    
    Метод read() возвращает объект bytes. Его можно преобразовать в строку с помощью метода decode() с передачей в качестве аргумента наименования кодировки:
        https://docs.python.org/3/library/stdtypes.html#bytes.decode
    
    >>> type(html)
    <class 'bytes'>
    >>> html = html.decode('utf-8')
    >>> type(html)
    <class 'str'>

Функция принимает обязательным аргументом URL, обязательным аргументом шаблон регулярного выражения и необязательным аргументом кодировку страницы.
    
    URL должен быть позиционно-ключевым аргументом, передаётся в виде объекта str. HTTP GET запрос по указанному адресу должен возвращать HTML документ.
    
    Шаблон регулярного выражения должен быть позиционно-ключевым аргументом, передаётся в виде объекта str.
        В шаблоне должно быть ровно две захватывающих группы.
    
    Кодировка страницы должна быть позиционно-ключевым аргументом, передаётся в виде объекта str, значение по умолчанию 'utf-8'

Функция возвращает путь к созданному JSON файлу в виде объекта Path.
    
    Имя создаваемого JSON файла должно быть взято из имени HTML файла в URL, если URL заканчивается на '.html'
    В противном случае, имя JSON файла должно быть эквивалентно имени файла текущего модуля без учёта расширения (см. тест ниже)
    
    Путь к файлу текущего модуля записан в атрибуте path объекта __loader__ в глобальном пространстве имён:
    >>> __loader__.path
    'D:\\G-Doc\\TOP Academy\\Python web\\q\\2023.06.29\\json_from_html.py'
    
    Во время записи в JSON файл обеспечьте запись всех символов UTF-8 и отступ два пробела на уровень отступа.

Для извлечения определённых данных из HTML документа используйте функцию findall() из модуля re стандартной библиотеки:
    https://docs.python.org/3/library/re.html#re.findall
    
    >>> data = findall(r'(\w)=(\d+)', 'i=0 j=1 k=2')
    >>> data
    [('i', '0'), ('j', '1'), ('k', '2')]
    
    Поскольку в каждом передаваемом в функцию json_from_html() шаблоне должно быть строго две захватывающих группы, то и элементами возвращаемого функцией findall() списка всегда будут кортежи из двух элементов.
    
    При вызове функции findall() воспользуйтесь флагом S из модуля re:
        https://docs.python.org/3/library/re.html#re.S
    
    >>> findall(r'\d.\d.\d', '0\n1\n2')
    []
    >>> findall(r'\d.\d.\d', '0\n1\n2', S)
    ['0\n1\n2']

Вы можете дополнительно реализовать любое количество вспомогательных функций с произвольными сигнатурами.

Примечание: не забывайте про встроенные функции globals(), any() и map(), а также про функции модуля itertools

Написанную функцию необходимо протестировать.

Примеры тестов:
    >>> url = 'https://docs.python.org/3/py-modindex.html'
    >>> modules_pattern = r'<tr>.+?>(\w+?)<.+?</td><td>.*?<em>(.*?)</em>'
    >>> 
    >>> file_path = json_from_html(url, modules_pattern)
    >>> 
    >>> file_path.name
    'py-modindex.json'
    >>> 
    >>> print(file_path.read_text(encoding='utf-8')[:110])
    {
      "__future__": "Future statement definitions",
      "__main__": "The environment where top-level code is run.
    >>> 
    >>> 
    >>> url = 'http://www.world-art.ru/cinema/rating_top.php'
    >>> films_pattern = (r'<tr .*?>'
    ...                  r'<td .*?<a.*?>(?P<name>.*?)</a>.*?</td>'
    ...                  r'<td .*?>(?P<rating>.*?)</td>')
    >>>
    >>> file_path = json_from_html(url, films_pattern)
    >>>
    >>> file_path.name
    'json_from_html.json'
    >>>
    >>> Path(__loader__.path).name
    'json_from_html.py'
    >>>
    >>> print(file_path.read_text(encoding='utf-8')[:110])
    {
      "Побег из Шоушенка": "8.9764",
      "Зелёная миля": "8.9561",
      "Форрест Гамп": "8.9066",
      "Леон": "8.8934",
    >>>



  =========================

Каждая функция должна быть документирована, её параметры и возвращаемое значение должны быть аннотированы.

Функции тестируются в режиме инспекции файла с кодом.
Ввод и вывод в стандартные потоки тестов и их результатов копируются.
Копия в виде комментария помещается в конец файла с кодом задачи.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении всех частей задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.